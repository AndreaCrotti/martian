<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>martian</title>
		<meta name="description" content="">
		<meta name="author" content="Oliver Hine">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-species-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/martian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background-image="img/curiosity.jpg" style="text-align: left;">
          <h1>martian</h1>
          <p style="color: white;">Oliver Hine</p>
          <br/><br/><br/><br/><br/><br/><br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/martian">
              <img class="logo" src="img/github.png"/>
              oliyh/martian
            </a>
          </div>
        </section>

        <section>
          <h2>HTTP in Clojure</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet []
  (http/post "https://api.com/create-pet/dog" {:as :json}))
          </code></pre>
          <aside class="notes">
            Libraries like clj-http let you make HTTP calls with a sensible, ring-like API.
            You're describing actions with data. Life is good.
            At this point you think: this is pretty sweet.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/sweet.jpg"/>
        </section>

        <section>
          <h2>Route params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json}))
          </code></pre>
          <aside class="notes">
            If you want to make a slightly different call to that API you would of course
            reuse all that code you just wrote - you're not a monster.
            But why are we formatting strings? What's going on?
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/what.jpg"/>
        </section>

        <section>
          <h2>query params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species age]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json
              :query-params {:age age}))
          </code></pre>
          <aside class="notes">
            Now we have another parameter, but it goes somewhere else in the HTTP request.
            This is starting to look bad.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/what-again.jpg"/>
        </section>

        <section>
          <h2>body params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species name age]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json
              :query-params {:age age}
              :body (json/encode {:name name))
              :headers {"Content-Type" "application/json"}}))
          </code></pre>
          <aside class="notes">
            Body parameters are even more complicated because they have to be encoded.
            Someone's getting angry.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/i-dare-you.jpg"/>
        </section>

        <section>
          <h2>metrics, environments, authentication...</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [metrics host port creds species name age]
  (timing metrics "create-pet"
    (http/post (format "https://%s:%s/create-pet/%s" host port species)
               {:as :json
                :query-params {:age age}
                :body (json/encode {:name name))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
          </code></pre>
          <aside class="notes">
            Cross-cutting, non-functional features like metrics, API authentication
            and environment variables quickly make the code unreadable.
            It's all gotten a bit much.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/i-double-dare-you.jpg"/>
        </section>

        <section>
          <h2>Signal to noise ratio</h2>
            <pre style="background: #3f3f3f;">
(defn create-pet [metrics host port creds species name age]
  (timing metrics "create-pet"
    (http/post (format "https://%s:%s/<span style="color: yellow;">create-pet</span>/%s" host port <span style="color: yellow;">species</span>)
               {:as :json
                :query-params {:name <span style="color: yellow;">name</span>}
                :body (json/encode {:age <span style="color: yellow;">age</span>))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
            </pre>
            <aside class="notes">
              If we look at that last request and pick out the bits we care about,
              the bits that drive functionality, we find there are only four.
              Functionality is the <strong>what</strong> that we are trying to achieve,
              that adds value to our software, and are domain level things that make sense to us.

              Everything else is the <strong>how</strong> and it doesn't really add any value
              to what we are trying to achieve and is the sort of thing that is
              better left to computers.

              For example, encoding - I don't really care how my computer talks to another computer,
              I want them to sort that out between them. I'm trying to solve problems in the business
              domain and that's hard enough without having to make decisions all the time on encoding.

              The signal to noise ratio is very low here, and that's something we can improve.
            </aside>
        </section>

        <section>
          <h2>The Server</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [request]
  (let [species (get-in request [:route-params :species])
        age (Integer/valueOf (get-in request [:query-params :age]))
        name (-> request
                 :body
                 (json/decode keyword)
                 :name)]
    (create-pet species name age)))
          </code></pre>
          <aside class="notes">
            Let's look at the corresponding code on the server.

            A server and a client should have a symmetric understanding of both the request and the response of
            any operation. In this case, they do - the operation takes the same parameters and does what we expect
            it to do, but this is far from obvious by looking at the code.

            In cases where they don't, and in unguarded code like this, you're going to get bad things happening -
            strings that should be numbers, nils that shouldn't be nils and so on.
          </aside>
        </section>

        <section>
          <h2>That's not a dog</h2>
          <br/>
          <img class="stretch" src="img/not-a-dog.jpg"/>
          <aside class="notes">
            When we pull apart the values of our domain object and sprinkle them into someone
            else's domain object, we're not in our domain anymore.

            If I create a pet of species dog, method put, name Charlie, content-type application/json,
            age 3, port 80 it will look like this. That is not a dog.
          </aside>
        </section>

        <section>
          <h2>Signatures</h2>
          <pre><code class="hljs" data-trim>
              (fn create-pet [species name age])
          </code></pre>
          <aside class="notes">
            Let's take a step back and consider what a request to an API is. We're asking a computer to
            perform operations on some data. Whether that API is remote or local, whether you talk to it with
            one protocol or another doesn't change the fundamental nature of what it does - the only way they
            differ is by how they do it.

            The simplest signatures are the ones that look like this where we pass in only
            what is needed to return the result, no more and no less, and as separately
            named and even typed values.
          </aside>
        </section>

        <section>
          <h2><em>This</em>&nbsp;&nbsp;is a dog</h2>
          <br/>
          <img class="stretch" src="img/a-dog.gif"/>
          <aside class="notes">
            When we talk about a dog called Charlie who's 3 years old, this is what we mean.

            This is much more evocative of what we want our code to actually do, and incidentally
            much more entertaining. Whenever you write code, I want you to see dogs blowing out
            candles on birthday cakes.
          </aside>
        </section>

        <section>
          <h2>Data describing data</h2>
          <pre><code class="hljs" data-trim>
{:route-params {:species Species}
 :query-params {:age Age}
 :body-params  {:name Name}
          </code></pre>
          <aside class="notes">
            The best way to map data from one domain to another is to describe data with data.
            That might sound like data everywhere, and it is, because it's a good thing.
            For our pet example it would look like this, if we used prismatic schema.
            We could describe it using clojure.spec as well, which would look slightly different, but the important thing is
            that we now have a tangible description of the signature which we can use to conform data from one shape to
            another, and that lets us do many things.
          </aside>
        </section>

        <section>
          <h2>API descriptions</h2>

          <pre><code class="hljs" data-trim>
(defhandler create-pet
  {:parameters {:path-params  {:species Species}
                :query-params {:age Age}
                :body-params  {:name Name}}
   :responses {201 {:body {:id Id}}}}
   ...)
          </code></pre>

          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/pedestal-api">
              <img class="logo" src="img/github.png"/>
              oliyh/pedestal-api
            </a>
          </div>

          <aside class="notes">
            Our server, which provides the API, could have descriptions for all its operations.
            We could use generic middleware to validate incoming requests against those descriptions, rejecting those with incorrect data.
            We could also coerce the data, so we don't have strings everywhere.
            These libraries already exist for your chosen web framework: compojure-api, pedestal-api, yada;
            they're easy to use. Furthermore, they generate and serve their own descriptions as json to clients to do interesting things with.
          </aside>
        </section>

        <section>
          <h2>Moves like Swagger</h2>
          <br/>
          <iframe class="stretch" style="background-color: white;" data-src="http://petstore.swagger.io/"></iframe>

          <aside class="notes">
            One thing we could generate is a Swagger description of the API.
            Swagger is also known as OpenAPI and is a cross language specification for describing
            APIs and a collection of tools for using these descriptions for various aims.
            One of these is the Swagger UI which lets us explore the API
            and use it from our browser. Notice how we can choose the operation and just type in our data.
          </aside>
        </section>

        <section>
          <h2>Make a Martian</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"))
          </code></pre>
          <aside class="notes">
            One of the other things we could also create a Martian record from the description.
            From this point on the var m will refer to a martian record which has been
            bootstrapped against the pet store API.
            So what can we do with this martian thing?
          </aside>
        </section>

        <section>
          <h2>Contact Martian</h2>
          <pre><code class="hljs" data-trim>
(martian/response-for m :create-pet {:name "Charlie"
                                     :species "Dog"
                                     :age 3})
          </code></pre>
          <aside class="notes">
            With martian we give the operation we want to call and the domain parameters it needs... and that's it!
            Martian understands the HTTPness of the API, so it can
            conform our domain data into the HTTP request we saw before using some simple operations and keep it all hidden.
            This one layer of indirection suddenly removes large amounts of code which had been obscuring the purpose and it looks
            like a normal function again.

            It takes care of content negotiation, serialisation and all the other things that I want the computers to work out between them.

            Everything else I'm going to talk about stems from being able to write this call in this way.
          </aside>
        </section>

        <section>
          <h2>What does it mean?</h2>
          <ul>
            <li>Cleaner code</li>
            <li>Specification always up-to-date</li>
            <li>Easier refactoring</li>
          </ul>
          <aside class="notes">
            It may seem like a small improvement to the code, but the implications are bigger than replacing five lines of code with one line.
            Your code is cleaner not just in terms of line count but in terms of concepts. You're no longer being asked to remember what HTTP status codes
            mean, or whether a parameter might need url encoding. Your mind is freed to concentrate on what it really means to create a pet and all the
            deep philosophical ramifications that has.

            It is also, without being obvious, DRY - don't repeat yourself. The description of the API is generated from the API itself so it's
            always guaranteed to be up to date. By writing your own code that says, for example, that species is a route parameter, you're unconciously
            repeating the code on the server with the usual caveat to repetition - one version will end up being wrong, and it's going to be the client side
            in this case.

            For this reason small refactorings to the API can be made without your code having to change at all. If a POST is changed to a PUT, or a url is
            changed, or a query parameter becomes a route parameter you won't have to change your code because you haven't specified those things on your side
            at all - you're letting the server describe all those things to you.
          </aside>
        </section>

        <section>
          <h2>Interceptors</h2>
          <br/>
          <img class="stretch" src="img/martian-call-stack.png"/>

          <aside class="notes">
            I'll just speak for a few minutes now on a pattern I used to implement martian.

            Anyone familiar with pedestal or even re-frame will have come across the concept of interceptors before.

            Essentially they behave like frames on a call stack - code that is executed before the next call down the stack, and code that is
            executed when the stack is popped back to this frame.

            However they are described by data - there's a bit of a theme here - and they can be manipulated like data. In order to do something
            like time a request we would want to add a frame to the call stack just before the HTTP request is made which would record the time
            at the start and the time at the end. When your call stack is data this just becomes a simple conj operation!

            Martian uses interceptors to perform each of the steps it takes between invocation and returning the response. These steps include
            conforming the HTTP request map, choosing the most efficient way to serialise data, making the http call, waiting for the response,
            deserialising it and returning it to the call site.

            By exposing Martian's interceptor stack in its API it allows the developer to manipulate it in any way they choose - removing operations,
            adding them, reordering them.

            This is martian's default interceptor stack.
          </aside>
        </section>

        <section>
          <h2>Security is everything</h2>
          <br/>
          <img class="stretch" src="img/security.gif"/>
          <aside class="notes">
            Let's write an interceptor to add authentication to all our requests.
          </aside>
        </section>

        <section>
          <h2>Authentication interceptor</h2>
          <pre><code class="hljs" data-trim>
(def authentication
  {:name ::authentication
   :enter (fn [ctx]
            (assoc-in ctx [:request :headers "Authorization"]
                      "Token: 12456abc"))})
          </code></pre>
          <aside class="notes">
            The context is a map containing the request, the response and any other bits of data we might want.
            To add authentication we just add a header called authorization with our special secret value.
            We do this in the enter phase, before the request is made.
          </aside>
        </section>

        <section>
          <h2>Update the call stack</h2>
          <br/>
          <img class="stretch" src="img/martian-call-stack-auth.png"/>
          <aside class="notes">
            This is where we want to insert authentication in the call stack
          </aside>
        </section>

        <section>
          <h2>Update the call stack</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"
        {:interceptors (concat martian/default-interceptors
                               [authentication
                                martian-http/encode-body
                                (martian-http/coerce-response)
                                martian-http/perform-request])}))
          </code></pre>
          <aside class="notes">
            We can provide our stack of interceptors to martian to execute instead of the default stack
          </aside>
        </section>

        <section>
          <h2>Timing is everything</h2>
          <img class="stretch" src="img/timing.gif"/>
          <aside class="notes">
            Now let's write an interceptor to time the request.
          </aside>
        </section>

        <section>
          <h2>Timing interceptor</h2>
          <pre><code class="hljs" data-trim>
(def timing
  {:name ::timing
   :enter (fn [ctx] (assoc ctx ::start (t/now)))
   :leave (fn [ctx] (assoc ctx ::duration
                           (t/minus (t/now) (::start ctx))))})
          </code></pre>
          <aside class="notes">
            Our timing interceptor has both an enter phase and a leave phase. The enter phase adds the start time to the context and
            when the http request is completed the stack is popped and we call the leave phase which calculates the duration.

            Notice that we don't even see the request or response map in this interceptor - this means we have achieved a nice
            clean separation between the functional and non-functional.
          </aside>
        </section>

        <section>
          <h2>Update the call stack (again!)</h2>
          <br/>
          <img class="stretch" src="img/martian-call-stack-auth-timing.png"/>
          <aside class="notes">
            This is where we want to insert timing around the actual request
          </aside>
        </section>

        <section>
          <h2>Update the call stack (again!)</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"
        {:interceptors (concat martian/default-interceptors
                               [authentication
                                martian-http/encode-body
                                (martian-http/coerce-response)
                                martian-http/perform-request
                                timing])}))
          </code></pre>
          <aside class="notes">
            Exposing the interceptor stack lets us do anything we wish at any point in the operation.
          </aside>
        </section>

        <section>
          <h2>Interceptors as an API</h2>
          <ul>
            <li>Better than multimethods</li>
            <li>Better than binding dynamic vars</li>
            <li>Better than arbitrary options maps</li>
          </ul>
          <aside class="notes">
            I realised that interceptors actually provide a brilliant way of allowing the developer to change the way the library works.
            They can have full control of what happens and when it happens - the martian library is a set of composable interceptors rather than
            a rigid framework.

            This makes it better than using multimethods as a way to let the developer extend behaviour, because multimethods only allow you to
            provide implementations for particular dispatch values. You can't choose how the dispatch values are chosen, you can't reorder anything,
            you can't add new behaviour, only adapt existing behaviour.

            They're better than binding dynamic vars because that's state and makes it hard to reason about how a system works, and has many of the same
            drawbacks as multimethods. Dynamic vars also cannot cross thread boundaries.

            They're also better than supporting arbitrary options maps, which are often poorly documented and still don't let you add or extend behaviour
            beyond what the author originally allows.



            I humbly submit that exposing the interceptor stack is the best way of making a library extendable, reusable and ultimately more useful to the
            developer whilst reducing the demand on the author to maintain and add features to it. I certainly plan to follow the same pattern for future libraries.
          </aside>
        </section>

        <section>
          <h2>Always test the right thing</h2>
          <br/>
          <img class="stretch" src="img/testing.gif">
          <aside class="notes">
            Testing HTTP integration has always been a bit tough. The most complete way is to
            start a stub server instance and capture requests so you can make some assertions on
            them.
          </aside>
        </section>

        <section>
          <h2>Stub servers</h2>
          <br/>
          <ul>
            <li>Drift away from real life</li>
            <li>Manually written cases</li>
            <li>Slow to run</li>
          </ul>
          <aside class="notes">
            Stub servers violate the don't repeat yourself principle - you're repeating code
            found in the remote API and this will always start to drift.
            When you write a stub handler you will probably not test every permutation of
            input and output, because that would mean a lot of code,
            and finally starting real servers takes time which adds up over many tests.
          </aside>
        </section>

        <section>
          <h2>Mocking</h2>
          <br/>
          <img class="stretch" src="img/max-power.gif">
          <aside class="notes">
            Mocked calls are the Max Power to the wrong way of stub servers. They're still wrong,
            but faster.
          </aside>
        </section>

        <section>
          <h2>martian-test</h2>
          </br>
          <ul>
            <li>Uses production definition - always correct</li>
            <li>Readable error messages</li>
            <li>Fast</li>
          </ul>

          <aside class="notes">
            Martian has a library called martian-test which replaces the HTTP call with assertions
            driven by the API's definition. This means no repetition, error messages are normal
            schema validation errors and it's as fast as mocking.
          </aside>
        </section>

        <section>
          <h2>martian-test example</h2>
          <pre><code class="hljs" data-trim>
(def m (-> (martian/bootstrap "https://petstore.com" api-definition)
           (martian-test/respond-with :success)))

(martian/response-for m :create-pet {:name "Charlie"})
;; => ExceptionInfo Value cannot be coerced to match schema:
;;                  {:species missing-required-key}

(martian/response-for m :create-pet {:name "Charlie"
                                     :species "Dog"
                                     :age 3})
;; => {:status 201, :body {:id -3}}
          </code></pre>
          <aside class="notes">
            When we bootstrap martian, we provide it with the martian-test interceptors

            When we make a bad call, like forgetting to provide the species of our pet for example,
            we get an exception which tells us this clearly.

            When we make a good call, it succeeds and we get a generated response.

            This means our tests can prove that we are always passing good data in to our
            API calls, which is a great thing. If someone changes an API in a way that's incompatible
            with the way you use it, you'll get a failing test.
          </aside>
        </section>

        <section>
          <h2>Response schemas</h2>
          <pre>
(defhandler create-pet
  {:parameters {:path-params  {:species Species}
                :query-params {:age Age}
                :body-params  {:name Name}}
   <span style="color: yellow;">:responses {201 {:body {:id Id}}
               401 {:body {:message s/Str}}
               402 {:body {:amount s/Int}}
               403 {:body {:message s/Str}}</span>
               ...}}
   ...)
          </pre>
          <aside class="notes">
            What about responses from these remote APIs? Swagger lets you describe possible
            responses as well as inputs, so we know all the possible values that can come back.

            Look at all those possible responses. What's the likelihood you'd only write a test for
            the 201 created response? What about all the others?
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/401.jpg"/>
          <aside class="notes">
            401 not authorised
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/402.jpg"/>
          <aside class="notes">
            402 payment required
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/403.jpg"/>
          <br/>
          <a href="https://http.cat">http.cat</a>
          <aside class="notes">
            403 forbidden

            By the way all these come from my favourite website http.cat which
            completely embraces the rule that your code should conjure up evocative images in your mind.

            As well as dogs with cakes you should be imagining a cat in a toilet every time you see a 403.
          </aside>
        </section>

        <section>
          <h2>Generating responses</h2>
          <pre><code class="hljs" data-trim>
(def create-pet-responses
  (martian-test/response-generator m :create-pet))

(generate create-pet-responses)
;; => {:status 200, :body {:id -1472372}}
          </code></pre>
          <aside class="notes">
            Creating a generator is easy - you just ask martian for one for the endpoint you
            want to test. They use schema generators underneath so behave in the same way.

            Already we're thinking more - what does it mean that an id could be negative?
            The age of a pet is optional, what happens when I load a pet that doesn't have an age?

            martian-test comes with all the plumbing you need to create a martian which will return
            generated responses and let you make generic assertions. You can for example assert that
            whenever a pet is successfully created, you always notify the user that their action was
            successful, or if there was a failure that something went wrong. Your integration tests
            can be much more robust. There are examples on how to do this on github.
          </aside>
        </section>

        <section>
          <h2>Assumptions vs Generative</h2>
          <br/>
          <img class="stretch" src="img/assumptions.gif">
          <aside class="notes">
            Assumptions in testing can be quite a dangerous thing. You might have tested that you can leap,
            assuming you're standing on a high friction surface.

            Assumptions about a remote API can easily creep into your codebase without you knowing:
            these assumptions are implicit and get lost as data propagates through your system.
            By explicitly describing the remote API at the edge of your system and using generative
            testing you can avoid a lot of pitfalls and get clearer errors when integrating.

            Generative tests force you to consider all the permutations that can exist and don't
            let you make these assumptions. Complexity significantly increases when you start interacting
            with remote services written by other people, and just because the service behaved as you expected
            it to for a narrow range of inputs you never know how it might behave under duress.
          </aside>
        </section>

        <section>
          <h2>No Swagger? No problem</h2>
          <pre><code class="hljs" data-trim>
(martian/bootstrap "https://api.org"
                   [{:route-name :create-pet
                     :path-parts ["/pets/" :species]
                     :method :put
                     :path-schema {:species s/Str}
                     :body-schema {:name                 s/Str
                                   (s/optional-key :age) s/Int}}]
                   {:produces ["application/json"]
                    :consumes ["application/json"]})
          </code></pre>
          <aside class="notes">
            Swagger is probably the most popular way that web APIs can self describe
            but not everyone uses it. You can still integrate with them using martian via
            a different bootstrap method that describes the API in a Swagger-like way.
            This gives you nearly all the benefits. One thing it won't help with is knowing when
            the remote API changes, but when it does change you can just update your definition
            and run your tests to see if anything breaks. If it doesn't you're good to go.
          </aside>
        </section>

        <section>
          <h2>Any implementation</h2>
          <br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/http-kit/http-kit">
              <img class="logo" src="img/github.png"/>
              http-kit/http-kit
            </a>
          </div>

          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/dakrone/clj-http">
              <img class="logo" src="img/github.png"/>
              dakrone/clj-http
            </a>
          </div>

          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/r0man/cljs-http">
              <img class="logo" src="img/github.png"/>
              r0man/cljs-http
            </a>
          </div>

          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/your-face/here">
              <img class="logo" style="width: 64px;" src="img/angrymartin.png"/>
              your-face/here
            </a>
          </div>

          <aside class="notes">
            The actual HTTP client you use underneath martian is up to you. The original driver
            behind this was using it in Clojurescript as well as in Clojure, and because everything
            is implemented as an interceptor this turned out to be really easy to do.

            You can even retain the behaviour of these libraries through martian - the asynchronous
            httpkit solution for example handles the leave phases of all the interceptors inside
            the callback which gets called when the response comes back, which is normally
            the place where your thread bindings would get lost and you've lost a lot of context.

            In martian, we pick up the entire context containing the interceptor queue and stack
            and put it into the callback - no context lost at all.
          </aside>
        </section>

        <section>
          <h2>Alternatives</h2>
          <br/>
          <div style="text-align: center; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="http://swagger.io/">
              <img class="logo" style="width: 128px; display: block; margin: 0 auto;" src="img/swagger.png"/>
              <br/>
              swagger
            </a>
          </div>

          <div style="text-align: center; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://twitter.github.io/finagle/">
              <img class="logo" style="width: 128px; display: block; margin: 0 auto;" src="img/finagle.png"/>
              <br/>
              finagle
            </a>
          </div>
          <aside class="notes">
            There are alternatives out there - you can even generate Clojure code from a Swagger
            definition at compile time. However I believe runtime better because data is better
            than functions and can open the way to generative testing and other things I've talked about.

            Twitter wrote a framework called finagle but to use it means you need to control both
            the server and the client, it's JVM only and there is no clojurescript equivalent.
          </aside>
        </section>

        <section>
          <h2>TL;DR</h2>
          <br/>
          <ul>
            <li>Separate your domain from implementation</li>
            <li>Describe data for great good</li>
            <li>Interceptor all the things</li>
          <aside class="notes">
            Keep your code simple and domain oriented
            Let computers do what computers do best

            Describing data and data generation open up huge improvements

            Interceptors provide ultimate flexibility in designing programmatic APIs
          </aside>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			history: true,
      margin: 0,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

      // setTimeout(window.location.reload.bind(window.location), 5000);
		</script>
	</body>
</html>
