<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>martian</title>
		<meta name="description" content="">
		<meta name="author" content="Oliver Hine">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-species-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/martian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background-image="img/curiosity.jpg" style="text-align: left;">
          <h1>martian</h1>
          <p style="color: white;">Oliver Hine</p>
          <br/><br/><br/><br/><br/><br/><br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/martian">
              <img class="logo" src="img/github.png"/>
              oliyh/martian
            </a>
          </div>
        </section>

        <section>
          <h2>HTTP in Clojure</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet []
  (http/post "https://api.com/create-pet/dog" {:as :json}))
          </code></pre>
          <aside class="notes">
            Libraries like clj-http let you make HTTP calls with a sensible, ring-like API.
            You're describing actions with data. Life is good.
            At this point you think: this is pretty sweet.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/sweet.jpg"/>
        </section>

        <section>
          <h2>Route params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json}))
          </code></pre>
          <aside class="notes">
            If you want to make a slightly different call to that API you would of course
            reuse all that code you just wrote - you're not a monster.
            But why are we formatting strings? What's going on?
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/what.jpg"/>
        </section>

        <section>
          <h2>query params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species age]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json
              :query-params {:age age}))
          </code></pre>
          <aside class="notes">
            Now we have another parameter, but it goes somewhere else in the HTTP request.
            This is starting to look bad.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/what-again.jpg"/>
        </section>

        <section>
          <h2>body params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species name age]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json
              :query-params {:age age}
              :body (json/encode {:name name))
              :headers {"Content-Type" "application/json"}}))
          </code></pre>
          <aside class="notes">
            Body parameters are even more complicated because they have to be encoded.
            Someone's getting angry.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/i-dare-you.jpg"/>
        </section>

        <section>
          <h2>metrics, environments, authentication...</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [metrics host port creds species name age]
  (timing metrics "create-pet"
    (http/post (format "https://%s:%s/create-pet/%s" host port species)
               {:as :json
                :query-params {:age age}
                :body (json/encode {:name name))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
          </code></pre>
          <aside class="notes">
            Cross-cutting, non-functional features like metrics, API authentication
            and environment variables quickly make the code unreadable.
            It's all gotten a bit much.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/i-double-dare-you.jpg"/>
        </section>

        <section>
          <h2>Signal to noise ratio</h2>
            <pre style="background: #3f3f3f;">
(defn create-pet [metrics host port creds species name age]
  (timing metrics "create-pet"
    (http/post (format "https://%s:%s/<span style="color: yellow;">create-pet</span>/%s" host port <span style="color: yellow;">species</span>)
               {:as :json
                :query-params {:name <span style="color: yellow;">name</span>}
                :body (json/encode {:age <span style="color: yellow;">age</span>))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
            </pre>
            <aside class="notes">
              If we look at that last request and pick out the bits we care about,
              the bits that drive functionality, we find there are only four.
              Functionality is the <strong>what</strong> that we are trying to achieve,
              that adds value to our software, and are domain level things that make sense to us.

              Everything else is the <strong>how</strong> and it doesn't really add any value
              to what we are trying to achieve and is the sort of thing that is
              better left to computers.

              For example, encoding - I don't really care how my computer talks to another computer,
              I want them to sort that out between them. I'm trying to solve problems in the business
              domain and that's hard enough without having to make decisions all the time on encoding.

              The signal to noise ratio is very low here, and that's something we can improve.
            </aside>
        </section>

        <section>
          <h2>The Server</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [request]
  (let [species (get-in request [:route-params :species])
        age (Integer/valueOf (get-in request [:query-params :age]))
        name (-> request
                 :body
                 (json/decode keyword)
                 :name)]
    (create-pet species name age)))
          </code></pre>
          <aside class="notes">
            Let's look at the corresponding code on the server.

            A server and a client should have a symmetric understanding of both the request and the response of
            any operation. In this case, they do - the operation takes the same parameters and does what we expect
            it to do, but this is far from obvious by looking at the code.

            In cases where they don't, and in unguarded code like this, you're going to get bad things happening -
            strings that should be numbers, nils that shouldn't be nils and so on.
          </aside>
        </section>

        <section>
          <h2>That's not a dog</h2>
          <br/>
          <img src="img/not-a-dog"/>
          picture of a uml diagram of a web request or an http spec or something
          <aside class="notes">
            When we pull apart the values of our domain object and sprinkle them into someone
            else's domain object, we're not in our domain anymore.

            This is what our dog looks like, except it's not a dog anymore.
          </aside>
        </section>

        <section>
          <h2>Signatures</h2>
          <pre><code class="hljs" data-trim>
              (fn create-pet [species name age])
          </code></pre>
          <aside class="notes">
            Let's take a step back and consider what a request to an API is. We're asking a computer to
            perform operations on some data. Whether that API is remote or local, whether you talk to it with
            one protocol or another doesn't change the fundamental nature of what it does - the only way they
            differ is by how they do it.

            The simplest signatures are the ones that look like this where we pass in only
            what is needed to return the result, no more and no less, and as separately
            named and even typed values.
          </aside>
        </section>

        <section>
          <h2><em>This</em>&nbsp;&nbsp;is a dog</h2>
          <br/>
          <img src="img/a-dog"/>
          picture of a dog with a name tag and a birthday cake with their age on it
          <aside class="notes">
            When we talk about a dog called Buster who's 4 years old, this is what we mean.

            This is much more evocative of what we want our code to actually do, and incidentally
            much more entertaining. Whenever you write code, I want you to see dogs blowing out
            candles on birthday cakes.
          </aside>
        </section>

        <section>
          <h2>Data describing data</h2>
          <pre><code class="hljs" data-trim>
{:route-params {:species Species}
 :query-params {:age Age}
 :body-params  {:name Name}
          </code></pre>
          <aside class="notes">
            What if we described our data using data? It would look like this, if we used prismatic schema.
            We could describe it using clojure.spec as well, which would look slightly different, but the important thing is
            that we now have a tangible description of the signature which we can use to conform data from one shape to
            another, and that lets us do many things.
          </aside>
        </section>

        <section>
          <h2>API descriptions</h2>

          <pre><code class="hljs" data-trim>
(defhandler create-pet
  {:parameters {:path-params  {:species Species}
                :query-params {:age Age}
                :body-params  {:name Name}}
   :responses {200 {:body {:id Id}}}}
   ...)
          </code></pre>

          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/pedestal-api">
              <img class="logo" src="img/github.png"/>
              oliyh/pedestal-api
            </a>
          </div>

          <aside class="notes">
            Our server, which provides the API, could have descriptions for all its operations.
            We could use generic middleware to validate incoming requests against those descriptions, rejecting those with incorrect data.
            We could also coerce the data, so we don't have strings everywhere.
            These libraries already exist for your chosen web framework: compojure-api, pedestal-api, yada;
            they're easy to use. Furthermore, they generate and serve their own descriptions as json to clients to do interesting things with.
          </aside>
        </section>

        <section>
          <h2>Swagger UI</h2>
          <br/>
          <iframe class="stretch" style="background-color: white;" data-src="http://petstore.swagger.io/"></iframe>

          <aside class="notes">
            One thing we could generate is a Swagger description of the API.
            If we do that, we can use the Swagger UI which lets us explore the API
            and send and receive data. Notice how we can choose the operation and just type in our data.
          </aside>
        </section>

        <section>
          <h2>Martian</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"))
          </code></pre>
          <aside class="notes">
            We could also create a Martian record from the description. From this point on
            the var m will refer to a martian record which has been bootstrapped against the pet store API.
          </aside>
        </section>

        <section>
          <h2>Martian</h2>
          <pre><code class="hljs" data-trim>
(martian/response-for m :create-pet {:name "Snoop"
                                     :species "Dog"
                                     :age 3})
          </code></pre>
          <aside class="notes">
            With martian we give the operation we want to call and the domain parameters it needs... and that's it!
            It conforms our domain data into the HTTP request we saw before using some simple operations and keeps it all hidden.
            This one layer of indirection suddenly removes large amounts of code which had been obscuring the purpose and it looks
            like a normal function again.

            It takes care of content negotiation, serialisation and all the other things that I want the computers to work out between them.
          </aside>
        </section>

        <section>
          <h2>What does it mean?</h2>
          <ul>
            <li>Cleaner code</li>
            <li>Specification always up-to-date</li>
            <li>Easier refactoring</li>
          </ul>
          <aside class="notes">
            It may seem like a small improvement to the code, but the implications are bigger than replacing five lines of code with one line.
            Your code is cleaner not just in terms of line count but in terms of concepts. You're no longer being asked to remember what HTTP status codes
            mean, or whether a parameter might need url encoding. Your mind is freed to concentrate on what it really means to create a pet and all the
            deep philosophical ramifications that has.

            It is also, without being obvious, DRY - don't repeat yourself. The description of the API is generated from the API itself so it's
            always guaranteed to be up to date. By writing your own code that says, for example, that species is a route parameter, you're unconciously
            repeating the code on the server with the usual caveat to repetition - one version will end up being wrong, and it's going to be the client side
            in this case.

            For this reason small refactorings to the API can be made without your code having to change at all. If a POST is changed to a PUT, or a url is
            changed, or a query parameter becomes a route parameter you won't have to change your code because you haven't specified those things on your side
            at all - you're letting the server describe all those things to you.
          </aside>
        </section>

        <section>
          <h2>Interceptors</h2>
          <br/>
          <img src="img/martian-call-stack.png" style="height: 55vh;"/>

          <aside class="notes">
            I'll just speak for a few minutes now on a pattern I used to implement martian.

            Anyone familiar with pedestal or even re-frame will have come across the concept of interceptors before.

            Essentially they behave like frames on a call stack - code that is executed before the next call down the stack, and code that is
            executed when the stack is popped back to this frame.

            However they are described by data - there's a bit of a theme here - and they can be manipulated like data. In order to do something
            like time a request we would want to add a frame to the call stack just before the HTTP request is made which would record the time
            at the start and the time at the end. When your call stack is data this just becomes a simple conj operation!

            Martian uses interceptors to perform each of the steps it takes between invocation and returning the response. These steps include
            conforming the HTTP request map, choosing the most efficient way to serialise data, making the http call, waiting for the response,
            deserialising it and returning it to the call site.

            By exposing Martian's interceptor stack in its API it allows the developer to manipulate it in any way they choose - removing operations,
            adding them, reordering them.

            This is martian's default interceptor stack.
          </aside>
        </section>

        <section>
          <h2>Security is everything</h2>
          <br/>
          <img src="img/security.gif"/>
          <aside class="notes">
            Let's write an interceptor to add authentication to all our requests.
          </aside>
        </section>

        <section>
          <h2>Authentication interceptor</h2>
          <pre><code class="hljs" data-trim>
(def authentication
  {:name ::authentication
   :enter (fn [ctx]
            (assoc-in ctx [:request :headers "Authorization"]
                      "Token: 12456abc"))})
          </code></pre>
          <aside class="notes">
            The context is a map containing the request, the response and any other bits of data we might want.
            To add authentication we just add a header called authorization with our special secret value.
            We do this in the enter phase, before the request is made.
          </aside>
        </section>

        <section>
          <h2>Update the call stack</h2>
          <br/>
          <img src="img/martian-call-stack-auth.png" style="height: 55vh;"/>
          <aside class="notes">
            This is where we want to insert authentication in the call stack
          </aside>
        </section>

        <section>
          <h2>Update the call stack</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"
        {:interceptors (concat martian/default-interceptors
                               [authentication
                                martian-http/encode-body
                                (martian-http/coerce-response)
                                martian-http/perform-request])}))
          </code></pre>
          <aside class="notes">
            We can provide our stack of interceptors to martian to execute instead of the default stack
          </aside>
        </section>

        <section>
          <h2>Timing is everything</h2>
          <img src="img/timing.gif"/>
          <aside class="notes">
            Now let's write an interceptor to time the request.
          </aside>
        </section>

        <section>
          <h2>Timing interceptor</h2>
          <pre><code class="hljs" data-trim>
(def timing
  {:name ::timing
   :enter (fn [ctx] (assoc ctx ::start (t/now)))
   :leave (fn [ctx] (assoc ctx ::duration
                           (t/minus (t/now) (::start ctx))))})
          </code></pre>
          <aside class="notes">
            Our timing interceptor has both an enter phase and a leave phase. The enter phase adds the start time to the context and
            when the http request is completed the stack is popped and we call the leave phase which calculates the duration.

            Notice that we don't even see the request or response map in this interceptor - this means we have achieved a nice
            clean separation between the functional and non-functional.
          </aside>
        </section>

        <section>
          <h2>Update the call stack (again!)</h2>
          <br/>
          <img src="img/martian-call-stack-auth-timing.png" style="height: 55vh;"/>
          <aside class="notes">
            This is where we want to insert timing around the actual request
          </aside>
        </section>

        <section>
          <h2>Update the call stack (again!)</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"
        {:interceptors (concat martian/default-interceptors
                               [authentication
                                martian-http/encode-body
                                (martian-http/coerce-response)
                                martian-http/perform-request
                                timing])}))
          </code></pre>
          <aside class="notes">
            Exposing the interceptor stack lets us do anything we wish at any point in the operation.
          </aside>
        </section>

        <section>
          <h2>Interceptors as an API</h2>
          <ul>
            <li>Better than multimethods</li>
            <li>Better than binding dynamic vars</li>
            <li>Better than arbitrary options maps</li>
          </ul>
          <aside class="notes">
            I realised that interceptors actually provide a brilliant way of allowing the developer to change the way the library works.
            They can have full control of what happens and when it happens - the martian library is a set of composable interceptors rather than
            a rigid framework.

            This makes it better than using multimethods as a way to let the developer extend behaviour, because multimethods only allow you to
            provide implementations for particular dispatch values. You can't choose how the dispatch values are chosen, you can't reorder anything,
            you can't add new behaviour, only adapt existing behaviour.

            They're better than binding dynamic vars because that's state and makes it hard to reason about how a system works, and has many of the same
            drawbacks as multimethods. Dynamic vars also cannot cross thread boundaries.

            They're also better than supporting arbitrary options maps, which are often poorly documented and still don't let you add or extend behaviour
            beyond what the author originally allows.



            I humbly submit that exposing the interceptor stack is the best way of making a library extendable, reusable and ultimately more useful to the
            developer whilst reducing the demand on the author to maintain and add features to it. I certainly plan to follow the same pattern for future libraries.
          </aside>
        </section>

        <section>
          <h2>Testing</h2>
          <br/>
          <img src="img/testing.gif">
          <aside class="notes">
            Testing HTTP integration has always been a bit tough. The most complete way is to
            start a stub server instance and capture requests so you can make some assertions on
            them.
          </aside>
        </section>

        <section>
          <h2>Stub servers</h2>
          <ul>
            <li>Drift away from real life</li>
            <li>Manually written cases</li>
            <li>Slow to run</li>
          </ul>
          <aside class="notes">
            Stub servers violate the don't repeat yourself principle - you're repeating code
            found in the remote API and this will always start to drift.
            When you write a stub handler you will probably not test every permutation of
            input and output, because that would mean a lot of code,
            and finally starting real servers takes time which adds up over many tests.
          </aside>
        </section>

        <section>
          <h2>Mocking</h2>
          <br/>
          <img src="img/max-power.gif">
          <aside class="notes">
            Mocked calls are the Max Power to the wrong way of stub servers. They're still wrong,
            but faster.
          </aside>
        </section>

        <section>
          <h2>martian-test</h2>
          <ul>
            <li>Uses production definition - always correct</li>
            <li>Readable error messages</li>
            <li>Fast</li>
          </ul>

          <aside class="notes">
            Martian has a library called martian-test which replaces the HTTP call with assertions
            driven by the API's definition. This means no repetition, error messages are normal
            schema validation errors and it's as fast as mocking.
          </aside>
        </section>

        <section>
          <h2>martian-test example</h2>
          <pre><code class="hljs" data-trim>
              show the bootstrap with the martian-test interceptors
              show making a call with bad params (like missing?) returning nice error
          </code></pre>
          <aside class="notes">
            When we bootstrap martian, we provide it with the martian-test interceptors

            ...

            This means our tests can prove that we are always passing good data in to our
            API calls, which is a great thing.
          </aside>
        </section>

        <section>
          <h2>Responses</h2>
          <pre>
(defhandler create-pet
  {:parameters {:path-params  {:species Species}
                :query-params {:age Age}
                :body-params  {:name Name}}
   <span style="color: yellow;">:responses {200 {:body {:id Id}}}</span>}
   ...)
          </pre>
          <aside class="notes">
            What about responses from these remote APIs? Swagger lets you describe possible
            responses as well as inputs, so we know all the possible values that can come back.
          </aside>
        </section>

        <section>
          <h2>Generating responses</h2>
          <pre><code class="hljs" data-trim>
              show code to generate a response, and the generated response
          </code></pre>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h2>Generative testing</h2>
          <pre><code class="hljs" data-trim>
              show generative test
              example handler could maybe try to parse :id as an integer when maybe it's a string
          </code></pre>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h2>No Swagger? No problem</h2>
          <pre><code class="hljs" data-trim>
              bootstrap with data
          </code></pre>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h2>Any implementation</h2>
          Implementations provided for clj-http, httpkit, cljs-http
          If you want to use something else, just write your own interceptor
          <aside class="notes">
            Again this is why interceptor API is good
          </aside>
        </section>

        <section>
          <h2>Alternatives</h2>
          swagger generated code
          finagle
          <aside class="notes">
            Runtime better because data is better than functions

            finagle means you need to control both the server and the client
          </aside>
        </section>

        <section>
          <h2>Conclusion</h2>
          Separate your domain from implementation
          Describe data for great good
          Interceptor all the things
          <aside class="notes">
            Keep your code simple and domain oriented
            Let computers do what computers do best

            Describing data lets you validate, generate

            Interceptors provide ultimate flexibility in designing programmatic APIs
          </aside>
        </section>



			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			history: true,
      margin: 0,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

      // setTimeout(window.location.reload.bind(window.location), 5000);
		</script>
	</body>
</html>
