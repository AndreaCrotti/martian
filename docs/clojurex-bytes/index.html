<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>martian</title>
		<meta name="description" content="">
		<meta name="author" content="Oliver Hine">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/martian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background-image="img/curiosity.jpg" style="text-align: left;">
          <h1>martian</h1>
          <p style="color: white;">Oliver Hine</p>
          <br/><br/><br/><br/><br/><br/><br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/martian">
              <img class="logo" src="img/github.png"/>
              oliyh/martian
            </a>
          </div>
        </section>

        <section>
          <section>
            <h2>HTTP in Clojure</h2>
            <pre><code class="hljs" data-trim>
(defn make-foo []
  (http/post "https://api.com/foo/bar" {:as :json}))
            </code></pre>
            <aside class="notes">
              Libraries like clj-http let you make HTTP calls with a sensible, ring-like API.
              At this point you think: this is pretty sweet.
            </aside>
          </section>

          <section>
            <img class="stretch" src="img/sweet.jpg"/>
          </section>

          <section>
            <h2>Route params</h2>
            <pre><code class="hljs" data-trim>
(defn make-foo [bar]
  (http/post (format "https://api.com/foo/%s" bar) {:as :json}))
            </code></pre>
            <aside class="notes">
              If you want to make a slightly different call to that API you would of course
              reuse all that code you just wrote - you're not a barbarian.
              But why are we formatting strings? What's going on?
            </aside>
          </section>

          <section>
            <img class="stretch" src="img/what.jpg"/>
          </section>

          <section>
            <h2>query params</h2>
            <pre><code class="hljs" data-trim>
(defn make-foo [bar baz]
  (http/post (format "https://api.com/foo/%s" bar)
             {:as :json
              :query-params {:baz baz}))
            </code></pre>
            <aside class="notes">
              Now we have another parameter, but it goes somewhere else in the HTTP request.
              This is starting to look bad.
            </aside>
          </section>

          <section>
            <img class="stretch" src="img/what-again.jpg"/>
          </section>

          <section>
            <h2>body params</h2>
            <pre><code class="hljs" data-trim>
(defn make-foo [bar baz qux]
  (http/post (format "https://api.com/foo/%s" bar)
             {:as :json
              :query-params {:baz baz}
              :body (json/encode {:qux qux))
              :headers {"Content-Type" "application/json"}}))
            </code></pre>
            <aside class="notes">
              Body parameters are even more complicated because they have to be encoded.
              Someone's getting angry.
            </aside>
          </section>

          <section>
            <img class="stretch" src="img/i-dare-you.jpg"/>
          </section>

          <section>
            <h2>metrics, environments, authentication...</h2>
            <pre><code class="hljs" data-trim>
(defn make-foo [metrics host port creds bar baz qux]
  (timing metrics "make-foo"
    (http/post (format "https://%s:%s/foo/%s" host port bar)
               {:as :json
                :query-params {:baz baz}
                :body (json/encode {:qux qux))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
            </code></pre>
            <aside class="notes">
              Cross-cutting, non-functional features like metrics, API authentication
              and environment variables quickly make the code unreadable.
              We've run out of patience.
            </aside>
          </section>

          <section>
            <img class="stretch" src="img/i-double-dare-you.jpg"/>
          </section>

        </section>

        <section>
          <h2>Signal to noise ratio</h2>
            <pre style="background: #3f3f3f;">
(defn make-foo [metrics host port creds bar baz qux]
  (timing metrics "make-foo"
    (http/post (format "https://%s:%s/<span style="color: yellow;">foo</span>/%s" host port <span style="color: yellow;">bar</span>)
               {:as :json
                :query-params {:baz <span style="color: yellow;">baz</span>}
                :body (json/encode {:qux <span style="color: yellow;">qux</span>))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
            </pre>
            <aside class="notes">
              Out of all this code, we only care about 4 things to drive functionality.
              Functionality is the <strong>what</strong> that we are trying to achieve,
              that adds value to our software, and is what humans are good at.

              Everything else is the <strong>how</strong> and it doesn't really add any value,
              is orthogonal to what we are trying to achieve and is the sort of thing that is
              better left to computers.

              The signal to noise ratio is very low here, and that's something I wanted to improve.
            </aside>
        </section>

        <section>
          <h2>The grass is always greener on the server side?</h2>
          <pre><code class="hljs" data-trim>
(defn foo [request]
  (let [bar (get-in request [:route-params :bar])
        baz (Integer/valueOf (get-in request [:query-params :baz]))
        qux (-> request
                :body
                (json/decode keyword)
                :qux)]
    (make-foo bar baz qux)))
          </code></pre>
          <aside class="notes">
            It's actually not much better on the server. At least our routing is done separately.
          </aside>
        </section>

        <section>
          <h2>Signatures</h2>
          <pre><code class="hljs" data-trim>
              make-foo :: bar -> baz -> qux
          </code></pre>
          <aside class="notes">
            The simplest signatures are the ones that look like this where we pass in only
            what is needed to return the result, no more and no less, and as separately
            named and even ideally typed values.

            You can think of an HTTP call to a remote API as a function. The handler you invoke is the operation,
            and the data you pass to it are parameters. All the other details - its asynchronicity, serialisation etc -
            are artifacts of the HTTP layer and not directly relevent to what you are trying to do.
          </aside>
        </section>

        <section>
          <h2>Signature descriptions</h2>
          <pre><code class="hljs" data-trim>
{:route-params {:bar Bar}
 :query-params {:baz Baz}
 :body-params  Qux}
          </code></pre>
          <aside class="notes">
            What if we described our signature as data? It would look like this, if we used prismatic schema.
            We could describe it using clojure.spec as well, which would look slightly different, but the important thing is
            that we now have a tangible description of the signature which we can use to conform data from one shape to
            another.
          </aside>
        </section>

        <section>
          <h2>Swagger UI</h2>

          <h1 style="color: red">embed swagger petstore here</h1>

          <aside class="notes">
            One thing we could generate is a Swagger description of the API.
            If we do that, we can use the Swagger UI which lets us explore the API
            and send and receive data. Notice how we can choose the operation and just type in our data.
          </aside>
        </section>

        <section>
          <h2>Server-side solutions</h2>
          <ul>
            <li>Validation</li>
            <li>Coercion</li>
          </ul>

          <h1 style="color: red">Ring, Pedestal, Yada, Fintrospect logos here</h1>

          <aside class="notes">
            Another thing we could do is have generic server code which could validate the incoming data, or return a 400.
            It could coerce the data, so we don't have strings everywhere.
            These libraries already exist for your chosen web framework: compojure-api, pedestal-api, yada, fintrospect;
            they're easy to use so there's no excuse not to.
          </aside>
        </section>


        <section>
          <section>
            <h2>Handler description</h2>
            <pre><code class="hljs" data-trim>
[{:operation-id ::make-foo
  :method       :post
  :path-parts   ["/foo/" :bar]
  :route-params {:bar Bar}
  :query-params {:baz Baz}
  :body-params  {:qux Qux}}]
            </code></pre>
            <aside class="notes">
              We want our client code to look like a normal function, so let's start a normalised description of
              the handler and make it available on the client. It might look something like this. Note the operation-id
              which identifies the operation.
            </aside>
          </section>

          <section>
            <h2>Query params example</h2>
            <pre><code class="hljs" data-trim>
(defn add-query-params [request handler params]
  (assoc request :query-params (select-keys params (keys (:query-schema handler)))))

(let [params {:bar "barrer"
              :baz "bazzer"
              :qux "quxxer"}]
  (-> {}
      (add-route-params handler params)
      (add-query-params handler params)
      (add-body-params handler params)))

 => {:url "/foo/barrer"
     :query-params {:baz "bazzer"}
     :body {:qux "quxxer"}}
            </code></pre>
            <aside class="notes">
              When you have described your data like this, conforming it to the required shape is easy.
              We know that query params has a key called baz, so we can look in the supplied parameters for the
              baz key and assoc it into the query params of the request.

              In the same way we can continue to build the request map up with urls, methods, bodies and everything else
              we had in the first few slides until we have the same request map but it's all driven by a description
              rather than imperative style code.
            </aside>
          </section>

          <section>
            <h2>Signature achieved!</h2>
            <pre><code class="hljs" data-trim>
(request-for handlers ::make-foo {:bar "barrer" :baz "bazzer" :qux "quxxer"})
            </code></pre>
            <aside class="notes">
              The only other thing we need is to use the operation id to choose the correct handler and we can
              build an http request with a signature like this; it now looks much more like a normal function.
            </aside>
          </section>

        </section>

        <section>
          <h2>What have we got?</h2>
          <ul>
            <li>Simple function signature</li>
            <li>HTTP implementation to be hidden</li>
            <li>HTTP library of choice</li>
            <li>Extension points</li>
            <li>Runtime discovery, not compile time</li>
          </ul>
          <aside class="notes">

          </aside>
        </section>


        <section>
          <h2></h2>
          <pre><code class="hljs" data-trim>

          </code></pre>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h2></h2>
          <pre><code class="hljs" data-trim>

          </code></pre>
          <aside class="notes">

          </aside>
        </section>


			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			history: true,
      margin: 0,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
