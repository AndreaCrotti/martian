<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>martian</title>
		<meta name="description" content="">
		<meta name="author" content="Oliver Hine">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-species-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/martian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background-image="img/curiosity.jpg" style="text-align: left;">
          <h1>martian</h1>
          <p style="color: white;">Oliver Hine</p>
          <br/><br/><br/><br/><br/><br/><br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/martian">
              <img class="logo" src="img/github.png"/>
              oliyh/martian
            </a>
          </div>
          <aside class="notes">
            Hello, I'm Oliver Hine
            Using Clojure for 5 years, in my day job for 4
            A consultant for Juxt
            Worked at OnTheMarket, two websites, data pipeline and satellites all in Clojure
            Now at Credit Suisse building Clojure/Script UI for traders, starting another Clojure project as well
            Today I'm going to talk about simplifying remote API integration, better ways to test integration and the library I wrote called martian that helps do this.
            It's available on github with more code examples and explanations.
          </aside>
        </section>

        <section>
          <h2>HTTP in Clojure</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet []
  (http/post "https://api.com/create-pet/dog" {:as :json}))
          </code></pre>
          <aside class="notes">
            Let's talk about HTTP. We all like HTTP, it's the lingua franca of the internet. There are all sorts of interesting APIs out there full of really useful information that we want to use.
            The project I'm currently working on collates data from the APIs of about 10 different systems via HTTP.
            Libraries like clj-http let you make HTTP calls with a sensible, ring-like API.
            I'm going to use the classic pet store analogy for the remote API I'm talking about, specifically the endpoint that lets you create a pet within the store.
            Here we are creating a dog, and it's super simple.
            I often use snippets of code like this, with some maps and filters, to show people how awesome and concise clojure is.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/sweet.jpg"/>
          <aside class="notes">
            At this point you think: this is pretty sweet.
          </aside>
        </section>

        <section>
          <h2>Route params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json}))
          </code></pre>
          <aside class="notes">
            If you want to make a slightly different call to that API you would of course reuse all that code you just wrote - you're not a monster.
            Here we are making the species of pet a parameter, and building the uri using format.
            But why are we formatting strings?
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/what.jpg"/>
          <aside class="notes">
            Isn't that a bit of a smell already?
          </aside>
        </section>

        <section>
          <h2>query params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species age]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json
              :query-params {:age age}))
          </code></pre>
          <aside class="notes">
            Now we have another parameter, the age of the pet, but it goes somewhere else in the HTTP request.
            How do we know that? We just do - it's implicit knowledge we have about the API.
            That implicit knowledge now exists in our codebase.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/what-again.jpg"/>
          <aside class="notes">
            It's just gotten a bit worse.
          </aside>
        </section>

        <section>
          <h2>body params</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [species name age]
  (http/post (format "https://api.com/create-pet/%s" species)
             {:as :json
              :query-params {:age age}
              :body (json/encode {:name name))
              :headers {"Content-Type" "application/json"}}))
          </code></pre>
          <aside class="notes">
            If we add a third parameter, the name of the pet, it gets worse still.
            Body parameters are even more complicated because they have to be encoded, and we have to say how we encoded them.
            We need to supply not just our data but also metadata about our data, and that goes in yet another place in the headers.
            We need to know that the header should be called Content-Type.
            We need to hope that the server understands the way we encoded it - that's more implicit knowledge we've built in.
            We've also made the assumption that the server can serve json back to us, but we don't know that either.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/i-dare-you.jpg"/>
          <aside class="notes">
            It can't get much worse, can it?
          </aside>
        </section>

        <section>
          <h2>metrics, environments, authentication...</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [metrics host port creds species name age]
  (timing metrics "create-pet"
    (http/post (format "https://%s:%s/create-pet/%s" host port species)
               {:as :json
                :query-params {:age age}
                :body (json/encode {:name name))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
          </code></pre>
          <aside class="notes">
            Cross-cutting, non-functional features like metrics, API authentication
            and environment variables quickly make the code even more unreadable.

            Our create-pet function takes loads of arguments that have nothing to do with the pet itself, and to understand that code you need to know more about HTTP than you do about pets.
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/i-double-dare-you.jpg"/>
          <aside class="notes">
            We should probably stop at this point, assuming it's not too late and we can get out alive.
          </aside>
        </section>

        <section>
          <h2>Signal to noise ratio</h2>
            <pre style="background: #3f3f3f;">
(defn create-pet [metrics host port creds species name age]
  (timing metrics "create-pet"
    (http/post (format "https://%s:%s/<span style="color: yellow;">create-pet</span>/%s" host port <span style="color: yellow;">species</span>)
               {:as :json
                :query-params {:name <span style="color: yellow;">name</span>}
                :body (json/encode {:age <span style="color: yellow;">age</span>))
                :headers {"Content-Type" "application/json"
                          "Authorization" (str "Token" creds)}})))
            </pre>
            <aside class="notes">
              If we look at that last request and pick out the bits we care about,
              the bits that drive functionality, we find there are only four.
              Functionality is what we are trying to achieve,
              that adds value to our software, and are domain level things that make sense to us.

              Everything else is how we do it, and it doesn't really add any value
              to what we are trying to achieve and is the sort of thing that is
              better left to computers.

              For example, encoding - I don't really care how my computer talks to another computer,
              I want them to sort that out between them. I'm trying to solve problems in the business
              domain and that's hard enough without having to make decisions all the time on things like encoding.

              The signal to noise ratio is very low here, and that's something we can improve.
            </aside>
        </section>

        <section>
          <h2>The Server</h2>
          <pre><code class="hljs" data-trim>
(defn create-pet [request]
  (let [species (get-in request [:route-params :species])
        age (Integer/valueOf (get-in request [:query-params :age]))
        name (-> request
                 :body
                 (json/decode keyword)
                 :name)]
    (create-pet species name age)))
          </code></pre>
          <aside class="notes">
            Let's look at the corresponding code on the server, the create-pet handler.

            A server and a client should have a symmetric understanding of both the request and the response of
            any operation. In this case, they do - the operation takes the same parameters and does what we expect
            it to do, but this is far from obvious by looking at how the client side packs it all up and the server side pulls it all out.

            In cases where they don't agree on the API, and in unguarded code like this, you're going to get bad things happening -
            strings that should be numbers, nils that shouldn't be nils and so on.

            The problem here is actually the same problem, just in reverse.
          </aside>
        </section>

        <section>
          <h2>That's not a dog</h2>
          <br/>
          <img class="stretch" src="img/not-a-dog.jpg"/>
          <aside class="notes">
            When we pull apart the values of our domain object and sprinkle them into someone
            else's domain object, we're not in our domain anymore. We're in a hybrid world that no one understands.
            The twilight zone, if you will.

            If I create a pet of species dog, method put, name Charlie, content-type application/json,
            age 3, port 80 it will look like this. That is not a dog.

            When our code creates a dog but it doesn't look like a dog we add cognitive overhead to our code.
            We have to trawl through bits of HTTP and try to pick out what looks important and this prevents you skimming code and understanding what it does.
            That sort of thing doesn't bode well for the longevity of a codebase.
          </aside>
        </section>

        <section>
          <h2>Signatures</h2>
          <pre><code class="hljs" data-trim>
              (fn create-pet [species name age])
          </code></pre>
          <aside class="notes">
            Let's take a step back and consider what a request to an API is. We're asking a computer to
            perform operations on some data. Whether that API is remote or local, whether you talk to it with
            one protocol or another doesn't change the fundamental nature of what it does - the only way they
            differ is by how they do it.

            The simplest signatures are the ones that look like this where we pass in only
            what is needed to return the result, no more and no less, and as separately
            named and even typed values.
          </aside>
        </section>

        <section>
          <h2><em>This</em>&nbsp;&nbsp;is a dog</h2>
          <br/>
          <img class="stretch" src="img/a-dog.gif"/>
          <aside class="notes">
            When we talk about a dog called Charlie who's 3 years old, this is what we mean.

            This is much more evocative of what our code actually does, and incidentally
            much more entertaining. Whenever you write or read code, I want you to see dogs blowing out
            candles on birthday cakes.

            Code like this is easy and unambiguous to read and understand, and this helps writing, learning, and refactoring.
          </aside>
        </section>

        <section>
          <h2>Data describing data</h2>
          <pre><code class="hljs" data-trim>
{:route-params {:species Species}
 :query-params {:age Age}
 :body-params  {:name Name}
          </code></pre>
          <aside class="notes">
            The best way to map data from one domain to another is to describe data with data.
            For our pet example it would look like this, if we used prismatic schema.
            We could describe it using clojure.spec as well, which would look slightly different, but the important thing is
            that we now have a tangible description of the signature which we can use to conform data from one shape to
            another, and that lets us do many things.

            Here we explicitly state that species is a route param, age a query param and name is a body param, and provide a schema for each value. There's no ambiguity here.
          </aside>
        </section>

        <section>
          <h2>API descriptions</h2>

          <pre><code class="hljs" data-trim>
(defhandler create-pet
  {:parameters {:path-params  {:species Species}
                :query-params {:age Age}
                :body-params  {:name Name}}
   :responses {201 {:body {:id Id}}}}
   ...)
          </code></pre>

          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/pedestal-api">
              <img class="logo" src="img/github.png"/>
              oliyh/pedestal-api
            </a>
          </div>

          <aside class="notes">
            Our server, which provides the API, could have descriptions like these for all its operations.
            Then we could use generic middleware to validate incoming requests against those descriptions, rejecting those with incorrect data.
            We could describe the encoding we support for requests and responses so that clients know if they'll be able to speak the same language.
            We could also coerce the data, so we don't have strings everywhere but actual primitive types.
            These libraries already exist for your chosen web framework: compojure-api, pedestal-api, yada;
            they're easy to use. Furthermore, they generate and serve their own descriptions as json to clients to do interesting things with.
          </aside>
        </section>

        <section>
          <h2>Moves like Swagger</h2>
          <br/>
          <iframe class="stretch" style="background-color: white;" data-src="http://petstore.swagger.io/"></iframe>

          <aside class="notes">
            One thing we could generate is a Swagger description of the API.
            Swagger is also known as OpenAPI and is a cross language specification for describing
            APIs and a collection of tools for using these descriptions for various aims.
            One of these is the Swagger UI which lets us explore the API
            and use it from our browser. Notice how we can choose the operation and just type in our data.
            Notice also that the swagger description is served as a json file.
          </aside>
        </section>

				<section data-background-image="img/mars-from-space.jpg" style="text-align: left;">
          <h1>life on mars</h1>
          <aside class="notes">
            That describes a bit where we've come from and where we want to go.
            I'm going to show you a bit of the martian library now which aims to get us there.
          </aside>
        </section>

        <section>
          <h2>Make a Martian</h2>
          <pre><code class="hljs" data-trim>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"))
          </code></pre>
          <aside class="notes">
            This is how you bootstrap a Martian record from the json served by a remote Swagger API.
            From this point on the var m will refer to a martian record which has been
            bootstrapped against the pet store API.
            One line of code to get you going. Let's see what else we can do.
          </aside>
        </section>

        <section>
          <h2>Contact Martian</h2>
          <pre><code class="hljs" data-trim>
(martian/response-for m :create-pet {:name "Charlie"
                                     :species "Dog"
                                     :age 3})
          </code></pre>
          <aside class="notes">
            With martian we give the operation we want to call and the domain parameters it needs... and that's it!
            Martian understands the HTTPness of the API, so it can
            conform our domain data into the HTTP request we saw before using some simple operations and keep it all hidden.
            This one layer of indirection suddenly removes large amounts of code which had been obscuring the purpose and it looks
            like a normal function again.

            It takes care of content negotiation, serialisation and all the other things that I want the computers to work out between them.

            All the advantages I'm going to talk about next stem from being able to write this call in this way, rather than the full verbose http map.
          </aside>
        </section>

        <section>
          <h2>What does it mean?</h2>
          <ul>
            <li>Cleaner code</li>
            <li>Specification always up-to-date</li>
            <li>Easier refactoring</li>
            <li>Explicit knowledge</li>
          </ul>
          <aside class="notes">
            It may seem like a small improvement to the code, but the implications are bigger than replacing five lines of code with one line.
            Your code is cleaner not just in terms of line count but in terms of concepts. You're no longer being asked to remember what HTTP status codes
            mean, or whether a parameter might need url encoding. Your mind is freed to concentrate on what it really means to create a pet and all the
            deep philosophical ramifications that has.

            It is also, without being obvious, DRY - don't repeat yourself. The description of the API is generated from the API itself so it's
            always guaranteed to be up to date. By writing your own code that says, for example, that species is a route parameter, you're unconciously
            repeating the code on the server with the usual caveat to repetition - one version will end up being wrong, and it's going to be the client side
            in this case.

            For this reason small refactorings to the API can be made without your code having to change at all. If a POST is changed to a PUT, or a url is
            changed, or a query parameter becomes a route parameter you won't have to change your code because you haven't specified those things on your side
            at all - you're letting the server describe all those things to you.

            We no longer have implicit knowledge about the API buried in our code, we're using the explicit description from the golden source - the remote API itself.
          </aside>
        </section>

        <section>
          <h2>Interceptors</h2>
          <br/>
          <img class="stretch" src="img/martian-call-stack.png"/>

          <aside class="notes">
            I'll just speak for a few minutes now on a pattern I used to implement martian.

            Anyone familiar with pedestal or even re-frame will have come across the concept of interceptors before.

            Essentially they behave like frames on a call stack - code that is executed before the next call down the stack, and code that is
            executed when the result bubbles back up.

            However they are described by data and they can be manipulated like data. In order to do something
            like time a request we would want to add a frame to the call stack just before the operation we want to time.
            When your call stack is data this just becomes a simple conj operation!

            Interceptors are like a reified call stack, and this is a very powerful concept.

            Martian uses interceptors to perform each of the steps it takes between invocation and returning the response. These steps shown here include
            conforming the HTTP request map with the method, url etc, choosing the most efficient way to serialise data on the way down on the left hand side,
            making the http call at the bottom, waiting for the response, then up the right hand side we are deserialising it and returning it to the call site.

            This is martian's default interceptor stack.
          </aside>
        </section>

        <section>
          <h2>Security is everything</h2>
          <br/>
          <img class="stretch" src="img/security.gif"/>
          <aside class="notes">
            Let's write an interceptor to add authentication to all our requests.
          </aside>
        </section>

        <section>
          <h2>Authentication interceptor</h2>
          <pre><code class="hljs" data-trim>
(def authentication
  {:name ::authentication
   :enter (fn [ctx]
            (assoc-in ctx [:request :headers "Authorization"]
                      "Token: 12456abc"))})
          </code></pre>
          <aside class="notes">
            The context is a map containing the request, the response and any other bits of data we might want.
            To add authentication we just add a header called authorization with our special secret value.
            We do this in the enter phase, before the request is made.

            Notice there is no mention of any pet in here - we have a nice separation of concerns. This interceptor just does authentication and doesn't pollute our domain.
          </aside>
        </section>

        <section>
          <h2>Update the call stack</h2>
          <br/>
          <img class="stretch" src="img/martian-call-stack-auth.png"/>
          <aside class="notes">
            This is where we want to insert authentication in the call stack.
            Normally if you want to insert some random operation halfway down the callstack of a library you're using, it's not going to be possible unless the library author thought to add an extension point there.

            As a library author you want to make your library useful and flexible, but you don't want a complicated API to support every conceivable thing developers might want to do.

            So what do you do?
          </aside>
        </section>

        <section>
          <h2>Update the call stack</h2>
          <pre><code class="hljs" data-trim data-noescape>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"
        {:interceptors (concat martian/default-interceptors
                               [<mark>authentication</mark>
                                martian-http/encode-body
                                (martian-http/coerce-response)
                                martian-http/perform-request])}))
          </code></pre>
          <aside class="notes">
            Martian exposes its interceptor stack in its API to allow the developer to manipulate it in any way they choose - removing operations, adding them, reordering them.

            We can provide our amended stack of interceptors to martian when we bootstrap it, to execute instead of the default stack, and so insert our authentication behaviour where we want it.

            Users of martian have almost complete control over the behaviour which means they don't need to wait for new releases to add new functionality.
            Instead they can just use the provided interceptors and compose them with their own like this.
          </aside>
        </section>

        <section>
          <h2>Timing is everything</h2>
          <img class="stretch" src="img/timing.gif"/>
          <aside class="notes">
            Now let's write an interceptor to time the request.
            This would normally be quite hard in other libraries because we want to time just the request and response,
            not all the other stuff that the library might do like deserialisation which might pollute the numbers.
            In martian it's easy, we just add an interceptor wherever we want.
          </aside>
        </section>

        <section>
          <h2>Timing interceptor</h2>
          <pre><code class="hljs" data-trim>
(def timing
  {:name ::timing
   :enter (fn [ctx] (assoc ctx ::start (t/now)))
   :leave (fn [ctx] (assoc ctx ::duration
                           (t/minus (t/now) (::start ctx))))})
          </code></pre>
          <aside class="notes">
            Our timing interceptor has both an enter phase and a leave phase. The enter phase happens before the request and adds the start time to the context and
            when the http request is completed we begin the leave phases which calculates the duration.

            Notice that we don't even see the request or response map in this interceptor - this one is all about timing, not about pets or HTTP.
            Again, we have achieved a nice clean separation between the functional and non-functional.
          </aside>
        </section>

        <section>
          <h2>Update the call stack (again!)</h2>
          <br/>
          <img class="stretch" src="img/martian-call-stack-auth-timing.png"/>
          <aside class="notes">
            This is where we want to insert timing around the actual request
          </aside>
        </section>

        <section>
          <h2>Update the call stack (again!)</h2>
          <pre><code class="hljs" data-trim data-noescape>
(def m (martian-http/bootstrap-swagger
        "https://pedestal-api.herokuapp.com/swagger.json"
        {:interceptors (concat martian/default-interceptors
                               [authentication
                                martian-http/encode-body
                                (martian-http/coerce-response)
                                <mark>timing</mark>
                                martian-http/perform-request])}))
          </code></pre>
          <aside class="notes">
            And again, it's simple just to add our interceptor to the stack whever we want.

            You should be able to implement any behaviour in this way, and each interceptor is a standalone piece of code that can be tested in isolation.
          </aside>
        </section>

        <section>
          <h2>Interceptors as an API</h2>
          <ul>
            <li>Better than multimethods</li>
            <li>Better than binding dynamic vars</li>
            <li>Better than arbitrary options maps</li>
          </ul>
          <aside class="notes">
            Interceptors actually provide a brilliant way of allowing the developer to change the way the library works.
            They can have full control of what happens and when it happens - the martian library is a set of composable interceptors rather than
            a rigid framework. Although interceptors were developed by the pedestal team as a bit of an extension to the ring specification, they provide generic behaviour and could be used in any library to provide all the benefits I've talked about.

            Traditionally you might choose multimethods, dynamic vars or an options map to let the developer change behaviour.

            Inteceptors are better than using multimethods because multimethods only allow you to
            provide implementations for particular dispatch values. You can't choose how the dispatch values are chosen, you can't reorder anything,
            you can't add new behaviour, only adapt existing behaviour.

            They're better than binding dynamic vars because they rely on state and makes it hard to reason about how a system works when state can change at any time, and also have many of the same
            drawbacks as multimethods. Dynamic vars also cannot cross thread boundaries so using httpkit with it's asynchronous response callback wouldn't work properly.

            They're also better than supporting arbitrary options maps, which are often poorly documented and still don't let you add or extend behaviour
            beyond what the author originally allows.

            I humbly submit that exposing the interceptor stack is the best way of making a library extendable, reusable and ultimately more useful to the
            developer whilst reducing the demand on the author to maintain and add features to it. I certainly plan to follow the same pattern for future libraries.
          </aside>
        </section>

				<section data-background-image="img/marscape.jpg" style="text-align: left;">
          <h1>Testing</h1>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h2>Always test the right thing</h2>
          <br/>
          <img class="stretch" src="img/testing.gif">
          <aside class="notes">
            Testing HTTP integration has always been a bit tough. The most complete way is to start a stub server instance and capture requests so you can make some assertions on them.
            Then we're making real requests and testing every part of the code. Is that enough?
          </aside>
        </section>

        <section>
          <h2>Stub servers</h2>
          <br/>
          <ul>
            <li>Drift away from real life</li>
            <li>Manually written cases</li>
            <li>Slow to run</li>
          </ul>
          <aside class="notes">
            Stub servers violate the don't repeat yourself principle - you're repeating code
            found in the remote API and this will always start to drift.
            When you write a stub handler you will probably not test every permutation of
            input and output, because that would mean a lot of code,
            and finally starting real servers takes time which adds up over many tests.
          </aside>
        </section>

        <section>
          <h2>Mocking</h2>
          <br/>
          <img class="stretch" src="img/max-power.gif">
          <aside class="notes">
            Mocked calls are the Max Power of stubbing. They're still wrong, just faster.

            They'll drift away from the production specification and they're only as complete as you make them.
          </aside>
        </section>

        <section>
          <h2>martian-test</h2>
          </br>
          <ul>
            <li>Uses production definition - always correct</li>
            <li>Generative - complete</li>
            <li>Fast</li>
            <li>Readable error messages</li>
          </ul>

          <aside class="notes">
            Martian has a sub library called martian-test which replaces the HTTP call with assertions
            driven by the API's definition. This means no repetition, we can use generative testing to easily test all the permutations of the responses the server could return, error messages are normal
            schema validation errors so very readable and it's as fast as mocking because it has no need to start a webserver.

            Let's look at an example of how to use it.
          </aside>
        </section>

        <section>
          <h2>martian-test example</h2>
          <pre><code class="hljs" data-trim>
(def m (-> (martian/bootstrap "https://petstore.com" api-definition)
           (martian-test/respond-with :success)))

(martian/response-for m :create-pet {:name "Charlie"})
;; => ExceptionInfo Value cannot be coerced to match schema:
;;                  {:species missing-required-key}

(martian/response-for m :create-pet {:name "Charlie"
                                     :species "Dog"
                                     :age 3})
;; => {:status 201, :body {:id -3}}
          </code></pre>
          <aside class="notes">
            When we bootstrap martian, we do it the same way as we do in production, so it has exactly the same definitions. This is very important.
            Then we tell it to always respond with success, at the top.

            This respond-with behaviour removes the interceptor which makes the actual http request and replaces it with one that simply generates a response.

            On the next line you see when we make a bad call, like forgetting to provide the species of our pet for example,
            we get an exception which tells us this clearly. We haven't had to call the server, we've just validated the request against the schema that the server has provided.

            Below that, when we make a good call, it succeeds and we get a generated response, and this response is generated from the responses that the server has told us it can generate without having to go near the server itself.

            This means our tests can prove that we are always passing good data in to our
            API calls, which is a really great thing to be able to test. If someone changes an API in a way that's incompatible
            with the way you use it, you'll get a failing test without hammering a real system with your test data.

            This shows the behaviour of the martian functions, but you can imagine your own code wrapped around these
            interacting with the data passing into and out of the remote API, and how this test behaviour can help.

            When you've built up your test suite you now have the ability to do something pretty special.
            If someone changes an API that you use in a way that will break your code, your tests will fail and you will know exactly where it broke.
            If they change their API in a way that won't break your code, you'll be confident that you're still compatible just by running your test suite.
            That's something I've never been able to do before.
          </aside>
        </section>

        <section>
          <h2>Response schemas</h2>
          <pre>
(defhandler create-pet
  {:parameters {:path-params  {:species Species}
                :query-params {:age Age}
                :body-params  {:name Name}}
   <span style="color: yellow;">:responses {201 {:body {:id Id}}
               401 {:body {:message s/Str}}
               402 {:body {:amount s/Int}}
               403 {:body {:message s/Str}}</span>
               ...}}
   ...)
          </pre>
          <aside class="notes">
            What about responses from these remote APIs? Swagger lets you describe possible
            responses as well as inputs, so we know all the possible values that can come back.

            Look at all those possible responses. What's the likelihood you'd only write a test for
            the 201 created response? What about all the others? What is a 402 anyway?
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/401.jpg"/>
          <aside class="notes">
            401 not authorised
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/402.jpg"/>
          <aside class="notes">
            402 payment required
          </aside>
        </section>

        <section>
          <img class="stretch" src="img/403.jpg"/>
          <br/>
          <a href="https://http.cat">http.cat</a>
          <aside class="notes">
            403 forbidden

            By the way all these come from my favourite website http.cat which
            completely embraces the rule that your code should conjure up evocative images in your mind.

            As well as dogs with cakes you should be imagining a cat in a toilet every time you see a 403.
          </aside>
        </section>

        <section>
          <h2>Generating responses</h2>
          <pre><code class="hljs" data-trim>
(def create-pet-responses
  (martian-test/response-generator m :create-pet))

(generate create-pet-responses)
;; => {:status 200, :body {:id -1472372}}
          </code></pre>
          <aside class="notes">
            You can also write truly generative tests using test.check.

            Creating a generator is easy - you just ask martian for one for the endpoint you
            want to test. They use schema generators underneath so behave in the same way.

            Already we're thinking more - what does it mean that an id could be negative?
            The age of a pet is optional, what happens when I load a pet that doesn't have an age?

            martian-test comes with all the plumbing you need to create a martian which will return
            generated responses and let you make generic assertions. You can for example assert that
            whenever a pet is successfully created, you always notify the user that their action was
            successful, or if there was a failure that something went wrong. Your integration tests
            can be much more robust. There are examples on how to do this on github.
          </aside>
        </section>

        <section>
          <h2>Assumptions</h2>
          <br/>
          <img class="stretch" src="img/assumptions.gif">
          <aside class="notes">
            Assumptions in testing can be quite a dangerous thing. You might have tested that you can leap,
            assuming you're standing on a high friction surface.

            Assumptions about a remote API can easily creep into your codebase without you knowing:
            these assumptions are implicit and get lost as data propagates through your system.
            By explicitly describing the remote API at the edge of your system and using generative
            testing you can avoid a lot of pitfalls and get clearer errors when integrating.

            Generative tests force you to consider all the permutations that can exist and don't
            let you make these assumptions. Complexity significantly increases when you start interacting
            with remote services written by other people, and just because the service behaved as you expected
            it to for a narrow range of inputs you never know how it might behave under duress.
          </aside>
        </section>

        <section>
          <h2>No Swagger? No problem</h2>
          <pre><code class="hljs" data-trim>
(martian/bootstrap "https://api.org"
                   [{:route-name :create-pet
                     :path-parts ["/pets/" :species]
                     :method :put
                     :path-schema {:species s/Str}
                     :body-schema {:name                 s/Str
                                   (s/optional-key :age) s/Int}}]
                   {:produces ["application/json"]
                    :consumes ["application/json"]})
          </code></pre>
          <aside class="notes">
            Swagger is probably the most popular way that web APIs can self describe but not everyone uses it.
            If they don't, and in fact most of them don't, you may think that there's little use and you'll have to go back to writing code that makes Samuel L Jackson angry.

            Good news though, you <b>can</b> integrate with these services using martian. You just use a different bootstrap method that describes the API in a Swagger-like way but is actually just clojure data.
            This gives you nearly all the benefits. One thing it won't help with is knowing when the remote API changes, but when it does change you can just update your definition and run your tests to see if anything breaks. If it doesn't you're good to go.
          </aside>
        </section>

        <section>
          <h2>Any implementation</h2>
          <br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/http-kit/http-kit">
              <img class="logo" src="img/github.png"/>
              http-kit/http-kit
            </a>
          </div>

          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/dakrone/clj-http">
              <img class="logo" src="img/github.png"/>
              dakrone/clj-http
            </a>
          </div>

          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/r0man/cljs-http">
              <img class="logo" src="img/github.png"/>
              r0man/cljs-http
            </a>
          </div>

          <div style="text-align: center; vertical-align: bottom; bottom: 0; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/your-face/here">
              <img class="logo" style="width: 64px;" src="img/angrymartin.png"/>
              your-face/here
            </a>
          </div>

          <aside class="notes">
            The actual HTTP client you use underneath martian is up to you. The original driver
            behind this was using it in Clojurescript as well as in Clojure, and because everything
            is implemented as an interceptor this turned out to be really easy to do.

            You can even retain the behaviour of these libraries through martian - the asynchronous
            httpkit solution for example handles the leave phases of all the interceptors inside
            the callback which gets called when the response comes back, which is normally
            the place where your thread bindings would get lost and you've lost a lot of context.

            In martian, we pick up the entire context containing the interceptor queue and stack
            and put it into the callback - no context lost at all.
          </aside>
        </section>

        <section>
          <h2>Alternatives</h2>
          <br/>
          <div style="text-align: center; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="http://swagger.io/">
              <img class="logo" style="width: 128px; display: block; margin: 0 auto;" src="img/swagger.png"/>
              <br/>
              swagger
            </a>
          </div>

          <div style="text-align: center; display: inline-block; padding: 12px;">
            <a style="color: white" class="github" target="_blank" href="https://twitter.github.io/finagle/">
              <img class="logo" style="width: 128px; display: block; margin: 0 auto;" src="img/finagle.png"/>
              <br/>
              finagle
            </a>
          </div>
          <aside class="notes">
            There are alternatives out there - you can even generate Clojure code from a Swagger definition at compile time. However I believe runtime is better because data is better than functions and can open the way to generative testing and other things I've talked about.

            Twitter wrote a framework called finagle but to use it means you need to control both the server and the client, it's JVM only and there is no clojurescript equivalent.
          </aside>
        </section>

        <section>
          <h2>TL;DR</h2>
          <br/>
          <ul>
            <li>Separate your domain from implementation</li>
            <li>Describe data for great good</li>
            <li>Interceptor all the things</li>
          <aside class="notes">
            Keep your code simple and domain oriented
            Let computers do what computers do best

            Describing data and data generation open up huge improvements

            Interceptors provide ultimate flexibility in designing programmatic APIs
          </aside>
        </section>

				<section data-background-image="img/curiosity-tracks.jpg" style="text-align: left;">
          <h1>Thanks</h1>
          <br/><br/><br/><br/><br/><br/><br/>
          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: white" class="github" target="_blank" href="https://github.com/oliyh/martian">
              <img class="logo" src="img/github.png"/>
              oliyh/martian
            </a>
          </div>
          <aside class="notes">
            Thanks
            Questions?
          </aside>
        </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			history: true,
      margin: 0,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

      // setTimeout(window.location.reload.bind(window.location), 5000);
		</script>
	</body>
</html>
